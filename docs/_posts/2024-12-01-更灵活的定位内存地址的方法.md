---
redirect_from: /_posts/2024-12-01-更灵活的定位内存地址的方法.md/
title: 更灵活的定位内存地址的方法
tags:

  - 汇编语言
---

# 一、and和or指令

不多说，就是与和或指令。

# 二、大小写转换问题

考虑一个问题，将一个字符串转换为全大写或全小写，不使用条件语句。

思路：考虑大小写的二进制。

![image-20241201135521141](https://cdn.jsdelivr.net/gh//wenqiangye/yesky_image/img/image-20241201135521141.png)

小写字母=大写字母+20H。

故可以直接使用and和or指令。

转换为大写：使用and指令，and al，1101 1111B

转换为小写：使用or指令，or al, 0010 0000B

# 三、[bx+idata]的方式处理数组

[bx+idata]表示一个内存单元，偏移地址为（bx)+idata

(ax)=((ds)*16+(bx)+idata)

```assembly
mov ax,[200+bx]
mov ax,200[bx]
mov ax,[bx].200
```

将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写

```assembly
assume cs:codesg,ds:datasg
datasg segment
	db 'BaSiC'
	db 'MinIX'
datasg ends

codesg segment
	start:
		mov ax,datasg
		mov ds,ax
		mov bx,0
		mov cx,5
	s:  mov al,[bx]
		and al,11011111b
		mov [bx],al
		inc bx
        loop s
        mov bx,5
    	mov cx,5
    s0: mov al,[bx]
    	or al,00100000b
    	mov [bx],al
    	inc bx
    	loop s0
    	
    	mov ax,4c00h
    	int 21h
codesg ends
end start
```

有了[bx+idata]，我们可以改写代码为：

```assembly
mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:	mov al,0[bx]
	and al,11011111b
	mov 0[bx],al
	mov al,5[bx]
	or al,00100000b
	mov 5[bx],al
	inc bx
	loop s
```

# 四、si和di

si和di是8086CPU中和bx功能相似的寄存器，但是si和di不能够分成两个8位寄存器。

寻址方式：

![image-20241201152639845](https://cdn.jsdelivr.net/gh//wenqiangye/yesky_image/img/image-20241201152639845.png)

双重循环时，loop默认的循环计数寄存器为cx，外层循环需要保存外层循环cx的值。用额外的内存，dataseg可以，但一般来说，在需要暂存数据的时候，我们都应该使用栈。

