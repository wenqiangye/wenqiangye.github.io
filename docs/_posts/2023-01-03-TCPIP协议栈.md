---
redirect_from: /_posts/2023-01-10-TCP-IP协议栈.md/
title: TCP/IP协议栈
tags:
  - TCP/IP网络编程
---

## TCP/IP协议栈

![摘自维基百科](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202301091427480.png)

TCP(Transmission Control Protocol) 传输控制协议。

从上到下分别为应用层、传输层、网络层、数据链路层。

### 一、数据链路层

在网线光缆等数据传输媒介中，数据是以电信号的形式传输，也就是0-1的电信号表示数据。且包含了物理地址。数据层则是解决**物理地址寻址**的问题。

**以太网协议**：以太网协议定义了数据帧，每一帧传输一段数据，如果数据很长，则需要分帧传输。每一个数据帧分为两个部分，head和data（TCP、IP协议也是分为两部分）。

Head部分：包含了**发送者、接收者、数据类型**等等；

Data部分：包含了传输的具体数据。

其中，**Head固定18为字节**，**Data部分最少46字节**，最长1500字节，因此每个数据帧最少为64字节，最长为1518字节。如果数据很长，则会**分为几个数据帧传输**，接收方接收后再进行整合获取数据。

**MAC地址**：Head部分中，包含了发送者和接收者信息，这个信息就是MAC地址。

**格式为FF-FF-FF-FF-FF-FF**,**12个十六进制数表示，前6为表示网卡的生产厂商，后6为表示这款网卡的生产序号**。（注：**以太网协议规定，所有网络的所有设备都必须有网卡接口，数据从一块网卡传入另一块网卡，MAC的地址就是网卡的地址，每块网卡有唯一的MAC地址**）

**广播**：以太网送数据时，把数据发送到网络内的总线上，网络内的所有计算机都可以拿到，拿到之后，拆开一看，目标MAC地址不是自身，就丢弃了；目标MAC地址是自身，就收下这个数据包并解析。。

### 二、网络层

以太网协议，依靠MAC地址发送数据，每个计算机都有唯一的MAC地址，理论上已经完全ok了，但是如果每个计算机都把自己要发的数据集都放在网络上，然后每个计算机都要解读其他所有计算机的数据包来看，这样计算机的负担太大，所以由此诞生了网络层。

网络层，定义了另一种地址，用来定义计算机所在的自网络。

**IP协议**：网络层定义的地址就是IP地址，规定网络地址的协议叫做IP协议。

目前广泛使用的是IPV4,但随着世界上计算机数量的增多，逐渐发现32位慢慢不够用了，就有了IPV6。

**子网掩码**：由于每个区域的差别，网络部分和主机部分的位数可能不一样，因此出现了子网掩码，用来判断两个IP是否在同一各网络。比如网络部分有16位，那么255.255.102.111的子网掩码就是255.255.0.0，通过判断两个计算机IP的子网掩码是否相同就可以知道是否处于同一个子网了。如果是同一个网络，就用广播的形式传递数据，如果不是，就把数据交回给路由，由路由传到下一跳。

**IP数据包**：包括head和data。head主要包括版本、长度、IP地址等信息。data为数据部分。其中，Head部分20-60字节 ，整个IP数据包最大为65535字节，由于以太网数据包Data部分最多1500字节，而IP协议数据包作为了以太协议的Data部分，所以，通常需要分为多个数据帧传输。意思就是在IP层传输的数据在数据链路层需要多个数据帧，因为数据链路层数据包的Data最多为1500字节，但是IP数据包最大为65535字节。

**ARP协议**：用IP地址拿到MAC地址。

1. 两台主机在不同的子网

   由于有了IP协议，不会再对子网之外进行广播了，所以不太好找到目标MAC地址，但是子网之外的东西**网关**会解决好的。

2. 两台主机在相同的子网

   可以使用ARP协议，ARP协议发送一个数据包，与IP协议相似，包含于以太数据包中。其中包含了本机IP地址，本机MAC地址，目标IP地址，目标MAC地址由于不知道，写的是FF:FF:FF:FF:FF:FF，用来表示这是个广播地址，**子网中的计算机都会拿到这个包，然后和自己的IP比较，如果相同，就知道这是个想要我MAC地址的的请求，把自己MAC地址回复。**

### 三、传输层

传输层进行数据的传输，前面IP层主要完成传输数据中路径选择的问题。传输层，实现端到端的传输。端口号为0-65535之间的一个整数，其中0-1023端口被系统占用，用户只能选择大于1023的端口。然后数据的发送寻址方式就变成了：**MAC地址+IP地址+端口**。**主机IP地址+端口，又叫做套接字**。因为有了端口这个东西，需要在原数据包基础上加东西来放这个端口啊，所以出现了UDP和TCP。

TCP：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

UDP：Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。

区别和总结：

1. TCP面向连接，通过三次握手建立连接，四次挥手接除连接;UDP是无连接的，即发送数据之前不需要建立连接，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。
2. TCP是可靠的通信方式。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现丢失、重复等等问题。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。
4. 每一条TCP连接只能是点到点的；而UDP不建立连接，所以可以支持一对一，一对多，多对一和多对多的交互通信，也就是可以同时接受多个人的包。
5. TCP需要建立连接，首部开销20字节相比8个字节的UDP显得比较大。
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

TCP三次握手四次挥手：

1. 三次握手:

   ![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202301102157884.png)

   第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。

   首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

   第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。

   在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

   第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

   确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

2. 四次挥手：

   ![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202301102159944.png)

   第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
   即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
   第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
   即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
   第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
   即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
   第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
   即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

### 四、应用层

制定了数据格式，用于对数据的封装与解读。
例如，TCP为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了"应用层"。



