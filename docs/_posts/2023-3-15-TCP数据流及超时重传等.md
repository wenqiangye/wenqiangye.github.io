---
redirect_from: /_posts/2023-3-15-TCP数据流及超时重传等.md/
title: TCP数据流及超时重传等.md
tags:
  - TCP/IP网络编程
---
# TCP数据流

## 交互数据：

交互数据仅包含很少的字节。使用交互数据的应用程序（协议）对实时性要求比较高，例如telnet，ssh等。

Nagle算法：

由于广域网上面携带这种微小TCP报文段数量一般很多，可能导致拥塞发生。

Nagle算法要求一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段，在该报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集需要发送的数据，在确认到来之后，这些数据会以一个TCP报文段发送出去，减少了网络上微小TCP报文段的数量。确认到达越快，数据发送得越快。

## 成块数据：

成块数据的长度通常为TCP报文段允许的最大长度。使用交互数据的应用程序（协议）对传输效率要求比较高，例如ftp。

当传输大量大块数据的时候，发送方会连续发送多个TCP报文段，接收方可以一次确认所有的报文段。能连续发送多少个TCP报文段，由接收窗口（拥塞窗口）的大小决定。另外，服务端会传送PSH标志给客户端，通知客户端的应用程序尽快读取数据。

## 带外数据：

有些传输层协议具有带外数据的概念，用于迅速通告对方本端发生的重要事件。

UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，用来传输紧急数据。

![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/IMG_1013.PNG)

# TCP超时重传

TCP服务必须能够足够重传超时时间内部未接收到确认的TCP报文段。

TCP模块为每个TCP报文段都维护一个**重传定时器**，该定时器在 TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应 答，**TCP模块将重传TCP报文段并重置定时器**。至于下次重传的超时 时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。

Linux有两个重要的内核参数与TCP超时重传相 关：/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。前者 **指定在底层IP接管之前TCP最少执行的重传次数，默认值是3**。后者**指 定连接放弃前TCP最多可以执行的重传次数，默认值是15（一般对应 13～30 min）**。在我们的实例中，**TCP超时重传发生了5次，连接坚持 的时间是15 min**（可以用date命令来测量）。

**虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生 在超时之前，即快速重传**

# 拥塞控制

提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。

## 慢启动和拥塞避免：

![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202303151349746.png)

慢启动和拥塞避免用来防止拥塞发生。

慢启动算法的理 由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一 种试探的方式平滑地增加CWND的大小。但是如果不施加其他手段，慢启动必然使得CWND很快膨胀（可 见慢启动其实不慢）并最终导致网络拥塞。因此TCP拥塞控制中定义了 另一个重要的状态变量：慢启动门限（slow start threshold size， ssthresh）。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避 免阶段。拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。

## 快速重传和快速恢复

拥塞发生时采取的方法。

判断拥塞发生的依据：

1. 传输超时，或者说TCP重传定时器溢出
2. 接收到重复的确认报文段。

拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使 用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复（如果是真的发生拥塞的话），第二种情 况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况 来对待。

如果发送端检测到拥塞发生是由于传输超时，即上述第一种情 况，那么它将执行重传并做如下调整： 其中FlightSize是已经发送但未收到确认的字节数。这样调整之 后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值 ssthresh（因为根据式（3-3），它一定不小于SMSS的2倍），故而拥塞 控制再次进入慢启动阶段。

$ssthresh=max(FlightSize/2,2*SMSS) \qquad\qquad(3-3)$

$CWMD<=SMSS$

其中FlightSize是已经发送但未收到确认的字节数。这样调整之 后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值 ssthresh（因为根据式（3-3），它一定不小于SMSS的2倍），故而拥塞 控制再次进入慢启动阶段。

发送端如果连续收到 3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和 快速恢复算法来处理拥塞，过程如下：

1）当收到第3个重复的确认报文段时，按照式（3-3）计算 ssthresh，然后立即重传丢失的报文段，并按照式（3-4）设置CWND。 

$CWND=ssthresh+3*SMSS \quad \qquad (3-4)$ 

2）每次收到1个重复的确认时，设置$CWND=CWND+SMSS$。此时发送端可以发送新的TCP报文段（如果新的$CWND$允许的话）。 

3）当收到新数据的确认时，设置CWND=ssthresh（ssthresh是新的 慢启动门限值，由第一步计算得到）。

 **快速重传和快速恢复完成之后，拥塞控制将恢复到拥塞避免阶段**，这一点由第3步操作可得知。
