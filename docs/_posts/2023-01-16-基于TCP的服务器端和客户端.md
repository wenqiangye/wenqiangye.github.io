---
redirect_from: /_posts/2023-01-16-基于TCP的服务器端和客户端.md/
title: 基于TCP的服务器端和客户端
tags:
  - TCP/IP网络编程
---

## 一、TCP服务器端的默认函数调用顺序

1.**TCP服务器端默认的函数调用顺序**

### ![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202301161743770.png)

​	socket()：**调用socket函数创建套接字，声明并初始化地址信息结构体变量，调用bind函数向套接字分配地址。**

2.**进入等待连接请求状态**

   前面调用了bind函数给套接字分配了地址，下一步通过调用listen函数进入等待连接请求状态。

   只有调用了listen函数，客户端才能进入可发出连接请求的状态，即客户端才能调用connect函数。

   ```c++
   #include<sys/socket.h>
   
   int listen(int sock ,int backlog);
   //成功时返回0，失败返回-1
   sock:希望进入等待连接请求的套接字文件描述符
   backlog:连接请求等待队列的长度
   ```

   **服务器的等待连接请求状态：客户端请求连接时，服务器在受理连接前一直使客户端的请求处于等待状态**

3.**受理客户端连接请求**

​	调用listen函数后，若有新的连接请求，则应按序受理。受理请求意味着进入可接受数据的状态。

```c++
	#include <sys/socket.h>

	int accept(int sock,struct sockaddr *addr,socklen_t *addrlen);

​	成功时返回创建的套接字文件描述符，失败时返回-1
​	sock：服务器套接字的文件描述符
​	addr：保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递进入函数的地址		
    变量参数填充客户端地址信息
​	addrlen：第二个参数addr结构体的长度，这里是存有长度的变量地址。函数调用完成后，	
    该变量即被填入客户端地址长度。
```

​	进入这种 **可以接收数据的状态所需参数中sock是服务器套接字**，但是服务器端套接字之前已经做了门卫，如果	还用一个套接字的话，**既要用来接收客户端的连接请求，一会又要和客户端进行数据传输**。

​	accept函数会自动创建一个新的套接字，并连接到发起请求的客户端，并作为返回值返回。
​	**accept 函数受理连接请求等待队列中 待处理的客户端连接请求。 函数调用成功时，accept函数内部将产生用于数据I/O的套接字，并返回其文件描述符**。

## 二、 **TCP客户端的默认函数调用顺序**

![](https://cdn.jsdelivr.net/gh/wenqiangye/yesky_image@main/img/202301201734015.png)

客户端的IP地址和端口在调用 connect函数时**自动分配**,无需调用标记的bind函数进行分配。







   

